mod config;
mod error;
mod flashcard;
mod state;

mod entity;
mod auth;
mod entries;
mod checkin;

use anyhow::Context;
use axum::routing::get;
use config::AppConfig;
use dotenvy::dotenv;
use sea_orm::{Database, Statement, ConnectionTrait};
use state::AppState;
use tower_http::{cors::CorsLayer, trace::TraceLayer};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    dotenv().ok();
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| {
                "german_learn=debug,axum::rejection=trace,tower_http=debug".into()
            }),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    let config = AppConfig::from_env().context("loading configuration")?;
    let db = Database::connect(&config.database_url)
        .await
        .context("connecting to database")?;
    ensure_user_tables(&db).await?;
    let shared_state = AppState::new(db, config.clone()).into_shared();

    let app = flashcard::router(shared_state.clone())
        .merge(auth::router(shared_state.clone()))
        .merge(entries::router(shared_state.clone()))
        .merge(checkin::router(shared_state.clone()))
        .route("/health", get(healthcheck))
        .layer(CorsLayer::permissive())
        .layer(TraceLayer::new_for_http());

    let listener = tokio::net::TcpListener::bind(&config.server_addr)
        .await
        .with_context(|| format!("binding to {}", config.server_addr))?;
    tracing::info!("listening on {}", config.server_addr);
    axum::serve(listener, app.into_make_service())
        .await
        .context("starting http server")
}

async fn healthcheck() -> &'static str {
    "ok"
}

async fn ensure_user_tables(db: &sea_orm::DatabaseConnection) -> anyhow::Result<()> {
    let backend = db.get_database_backend();
    // Users table
    db.execute(Statement::from_string(backend, r#"
        CREATE TABLE IF NOT EXISTS users (
            user_id TEXT PRIMARY KEY,
            email   TEXT UNIQUE,
            name    TEXT,
            password_hash TEXT,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
    "#.to_string())).await?;
    // Backfill columns if table existed
    db.execute(Statement::from_string(backend, r#"
        ALTER TABLE users ADD COLUMN IF NOT EXISTS email TEXT;
    "#.to_string())).await?;
    db.execute(Statement::from_string(backend, r#"
        ALTER TABLE users ADD COLUMN IF NOT EXISTS name TEXT;
    "#.to_string())).await?;
    db.execute(Statement::from_string(backend, r#"
        ALTER TABLE users ADD COLUMN IF NOT EXISTS password_hash TEXT;
    "#.to_string())).await?;
    db.execute(Statement::from_string(backend, r#"
        CREATE UNIQUE INDEX IF NOT EXISTS idx_users_email ON users(email);
    "#.to_string())).await?;

    // user_flashcard_progress
    db.execute(Statement::from_string(backend, r#"
        CREATE TABLE IF NOT EXISTS user_flashcard_progress (
            progress_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            user_id         TEXT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
            entry_id        INTEGER NOT NULL REFERENCES vocabulary_entries(entry_id) ON DELETE CASCADE,
            status          TEXT    NOT NULL,
            times_seen      INTEGER NOT NULL,
            times_mastered  INTEGER NOT NULL,
            last_seen_at    TIMESTAMPTZ,
            created_at      TIMESTAMPTZ NOT NULL,
            updated_at      TIMESTAMPTZ NOT NULL,
            UNIQUE(user_id, entry_id)
        );
    "#.to_string())).await?;
    db.execute(Statement::from_string(backend, r#"
        CREATE INDEX IF NOT EXISTS idx_user_flashcard_progress_user
            ON user_flashcard_progress (user_id);
    "#.to_string())).await?;

    // user_flashcard_reviews
    db.execute(Statement::from_string(backend, r#"
        CREATE TABLE IF NOT EXISTS user_flashcard_reviews (
            review_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            user_id      TEXT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
            entry_id     INTEGER NOT NULL REFERENCES vocabulary_entries(entry_id) ON DELETE CASCADE,
            result       TEXT    NOT NULL,
            notes        TEXT,
            reviewed_at  TIMESTAMPTZ NOT NULL
        );
    "#.to_string())).await?;
    db.execute(Statement::from_string(backend, r#"
        CREATE INDEX IF NOT EXISTS idx_user_flashcard_reviews_user
            ON user_flashcard_reviews (user_id);
    "#.to_string())).await?;

    // Add owner column to vocabulary_entries for personal entries
    db.execute(Statement::from_string(backend, r#"
        ALTER TABLE vocabulary_entries
          ADD COLUMN IF NOT EXISTS user_owner TEXT REFERENCES users(user_id) ON DELETE SET NULL;
    "#.to_string())).await?;
    db.execute(Statement::from_string(backend, r#"
        CREATE INDEX IF NOT EXISTS idx_vocabulary_entries_owner
          ON vocabulary_entries (user_owner);
    "#.to_string())).await?;

    // user daily check-ins
    db.execute(Statement::from_string(backend, r#"
        CREATE TABLE IF NOT EXISTS user_checkins (
            user_id   TEXT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
            day       DATE NOT NULL,
            checked_at TIMESTAMPTZ NOT NULL,
            PRIMARY KEY(user_id, day)
        );
    "#.to_string())).await?;
    db.execute(Statement::from_string(backend, r#"
        CREATE INDEX IF NOT EXISTS idx_user_checkins_user
            ON user_checkins (user_id, day);
    "#.to_string())).await?;

    Ok(())
}
